            "policy": access_policy,
            "encrypted_message": encrypted_message
        }
        
        return ciphertext
    
    def decrypt_with_attributes(self, ciphertext, attribute_key, user_attributes):
        """
        使用属性密钥解密
        只有满足访问策略的用户才能解密成功
        """
        # 1. 验证用户属性是否满足访问策略
        if not self.satisfy_policy(user_attributes, ciphertext["policy"]):
            raise PermissionError("用户属性不满足访问策略")
        
        # 2. 计算解密密钥
        # K = e(C0, SK_attr) / e(C_attr, P2)
        numerator = self.pairing_elements(ciphertext["C0"], attribute_key)
        
        denominator = 1
        for attr in user_attributes:
            if attr in ciphertext["C_components"]:
                C_attr = ciphertext["C_components"][attr]
                denominator *= self.pairing_elements(C_attr, self.P2)
        
        K = numerator / denominator
        
        # 3. 派生对称密钥并解密消息
        symmetric_key = self.kdf(K)
        message = self.symmetric_decrypt(ciphertext["encrypted_message"], symmetric_key)
        
        return message

**医生访问病历的SM9应用：**
def doctor_access_medical_record_with_sm9():
    """完整的基于属性的病历访问流程"""
    
    # === 系统初始化阶段 ===
    sm9 = SM9AttributeBasedEncryption()
    mpk, msk = sm9.setup()
    
    # === 医生注册阶段 ===
    # 医生李华的属性
    doctor_attributes = {
        "department": "心内科",
        "position": "主治医师",
        "hospital": "市人民医院",
        "license_id": "DOC123456"
    }
    
    # KMS为医生生成属性密钥
    doctor_attr_key = sm9.extract_attribute_key(
        list(doctor_attributes.values()),
        msk
    )
    
    # === 病历加密存储阶段 ===
    # 定义访问策略（只有心内科的主治医师及以上才能访问）
    access_policy = """
    (department = "心内科") AND 
    (position IN ["主治医师", "副主任医师", "主任医师"])
    """
    
    # 加密病历
    medical_record = {
        "patient_id": "P001",
        "diagnosis": "高血压2级",
        "prescription": "氨氯地平 5mg qd"
    }
    
    ciphertext = sm9.encrypt_with_policy(
        json.dumps(medical_record),
        access_policy,
        mpk
    )
    
    # === 医生访问阶段 ===
    try:
        # 医生李华使用自己的属性密钥解密
        decrypted_record = sm9.decrypt_with_attributes(
            ciphertext,
            doctor_attr_key,
            list(doctor_attributes.values())
        )
        
        print("✓ 解密成功，医生李华有权访问")
        print(json.loads(decrypted_record))
        
    except PermissionError as e:
        print(f"✗ 访问被拒绝：{e}")
    
    # === 非授权访问尝试 ===
    # 护士试图访问（属性不满足）
    nurse_attributes = {
        "department": "心内科",
        "position": "护士",  # 职位不符合
        "hospital": "市人民医院"
    }
    
    nurse_attr_key = sm9.extract_attribute_key(
        list(nurse_attributes.values()),
        msk
    )
    
    try:
        sm9.decrypt_with_attributes(
            ciphertext,
            nurse_attr_key,
            list(nurse_attributes.values())
        )
    except PermissionError:
        print("✓ 护士访问被正确拒绝（属性不匹配）")

#### **Paillier同态加密（隐私AI计算）**
class PaillierHomomorphicEncryption:
    """
    Paillier同态加密系统
    支持加密数据的加法和标量乘法运算
    """
    
    def __init__(self, key_length=2048):
        self.key_length = key_length
        self.public_key = None
        self.private_key = None
    
    def generate_keypair(self):
        """生成Paillier密钥对"""
        # 1. 选择两个大素数 p, q
        p = self.generate_prime(self.key_length // 2)
        q = self.generate_prime(self.key_length // 2)
        
        # 2. 计算 n = p * q
        n = p * q
        
        # 3. 计算 λ = lcm(p-1, q-1)
        lambda_n = self.lcm(p - 1, q - 1)
        
        # 4. 选择生成元 g（通常选择 g = n + 1）
        g = n + 1
        
        # 5. 计算 μ = (L(g^λ mod n²))^(-1) mod n
        # L(x) = (x - 1) / n
        g_lambda = pow(g, lambda_n, n * n)
        L_value = (g_lambda - 1) // n
        mu = pow(L_value, -1, n)
        
        self.public_key = (n, g)
        self.private_key = (lambda_n, mu, p, q)
        
        return (self.public_key, self.private_key)
    
    def encrypt(self, plaintext, public_key=None):
        """
        加密明文消息
        E(m) = g^m * r^n mod n²
        其中 r 是随机数
        """
        if public_key is None:
            public_key = self.public_key
        
        n, g = public_key
        n_square = n * n
        
        # 1. 选择随机数 r ∈ Z_n*
        r = secrets.randbelow(n)
        while self.gcd(r, n) != 1:
            r = secrets.randbelow(n)
        
        # 2. 计算 c = g^m * r^n mod n²
        g_m = pow(g, plaintext, n_square)
        r_n = pow(r, n, n_square)
        ciphertext = (g_m * r_n) % n_square
        
        return ciphertext
    
    def decrypt(self, ciphertext, private_key=None):
        """
        解密密文
        D(c) = L(c^λ mod n²) * μ mod n
        """
        if private_key is None:
            private_key = self.private_key
        
        lambda_n, mu, p, q = private_key
        n = p * q
        n_square = n * n
        
        # 1. 计算 c^λ mod n²
        c_lambda = pow(ciphertext, lambda_n, n_square)
        
        # 2. 计算 L(c^λ)
        L_value = (c_lambda - 1) // n
        
        # 3. 计算明文 m = L_value * μ mod n
        plaintext = (L_value * mu) % n
        
        return plaintext
    
    def add_encrypted(self, c1, c2, public_key=None):
        """
        同态加法：E(m1) * E(m2) = E(m1 + m2)
        """
        if public_key is None:
            public_key = self.public_key
        
        n, g = public_key
        n_square = n * n
        
        return (c1 * c2) % n_square
    
    def multiply_scalar(self, ciphertext, scalar, public_key=None):
        """
        同态标量乘法：E(m)^k = E(k * m)
        """
        if public_key is None:
            public_key = self.public_key
        
        n, g = public_key
        n_square = n * n
        
        return pow(ciphertext, scalar, n_square)

**AI模型在加密数据上的计算示例：**
def privacy_preserving_ai_diagnosis():
    """隐私保护的AI诊断完整流程"""
    
    # === 初始化Paillier系统 ===
    paillier = PaillierHomomorphicEncryption(key_length=2048)
    pub_key, priv_key = paillier.generate_keypair()
    
    # === 患者端：加密症状特征 ===
    # 原始特征向量（10维）
    symptoms_features = [
        45,   # 年龄
        1,    # 性别（1=男）
        175,  # 身高cm
        80,   # 体重kg
        150,  # 收缩压
        95,   # 舒张压
        88,   # 心率
        1,    # 有高血压病史
        0,    # 无糖尿病史
        1     # 有头晕症状
    ]
    
    # 在患者设备上加密
    encrypted_features = [
        paillier.encrypt(feature, pub_key) 
        for feature in symptoms_features
    ]
    
    print("✓ 患者端：特征向量已加密")
    print(f"  明文特征: {symptoms_features}")
    print(f"  密文示例: {encrypted_features[0]} (年龄45的密文)")
    
    # === 服务器端：AI模型在加密数据上计算 ===
    # 预训练的逻辑回归模型参数（明文）
    model_weights = [
        0.5,   # 年龄权重
        1.2,   # 性别权重
        -0.1,  # 身高权重
        0.3,   # 体重权重
        2.5,   # 收缩压权重（高影响）
        1.8,   # 舒张压权重
        0.4,   # 心率权重
        3.0,   # 高血压病史权重（高影响）
        1.5,   # 糖尿病史权重
        2.0    # 头晕症状权重
    ]
    model_bias = -50.0
    
    # 在加密特征上计算风险分数
    # score = Σ(w_i * x_i) + bias
    
    # 初始化为E(0)
    encrypted_score = paillier.encrypt(0, pub_key)
    
    # 累加每个加权特征
    for i, enc_feature in enumerate(encrypted_features):
        weight = int(model_weights[i] * 10)  # 放大10倍避免小数
        
        # E(x_i)^w_i = E(w_i * x_i)
        weighted_feature = paillier.multiply_scalar(enc_feature, weight, pub_key)
        
        # E(sum) * E(w_i * x_i) = E(sum + w_i * x_i)
        encrypted_score = paillier.add_encrypted(encrypted_score, weighted_feature, pub_key)
    
    # 添加偏置项
    encrypted_bias = paillier.encrypt(int(model_bias * 10), pub_key)
    encrypted_score = paillier.add_encrypted(encrypted_score, encrypted_bias, pub_key)
    
    print("✓ 服务器端：AI模型已在加密数据上完成计算")
    print(f"  加密风险分数: {encrypted_score}")
    
    # === 患者端：解密结果 ===
    decrypted_score = paillier.decrypt(encrypted_score, priv_key) / 10  # 还原缩放
    
    print("✓ 患者端：解密诊断结果")
    print(f"  风险评分: {decrypted_score}")
    
    # === 验证计算正确性 ===
    # 明文计算对比
    plaintext_score = sum(
        w * x for w, x in zip(model_weights, symptoms_features)
    ) + model_bias
    
    print(f"\n验证:")
    print(f"  加密计算结果: {decrypted_score}")
    print(f"  明文计算结果: {plaintext_score}")
    print(f"  误差: {abs(decrypted_score - plaintext_score)}")
    
    # === 添加差分隐私噪声 ===
    noise = np.random.laplace(0, 5)  # 拉普拉斯噪声
    noisy_score = decrypted_score + noise
    
    print(f"\n差分隐私保护:")
    print(f"  添加噪声: {noise}")
    print(f"  最终评分: {noisy_score}")
    
    return noisy_score

---

### **3.2 区块链存证机制**

#### **简化区块链实现**
class MedicalBlockchain:
    """医疗数据区块链存证系统"""
    
    def __init__(self):
        self.chain = []
        self.pending_transactions = []
        self.create_genesis_block()
    
    def create_genesis_block(self):
        """创建创世区块"""
        genesis_block = {
            "index": 0,
            "timestamp": "2024-01-01 00:00:00",
            "transactions": [],
            "previous_hash": "0" * 64,
            "nonce": 0
        }
        genesis_block["hash"] = self.calculate_hash(genesis_block)
        self.chain.append(genesis_block)
    
    def calculate_hash(self, block):
        """计算区块哈希（使用SM3）"""
        block_string = json.dumps({
            "index": block["index"],
            "timestamp": block["timestamp"],
            "transactions": block["transactions"],
            "previous_hash": block["previous_hash"],
            "nonce": block.get("nonce", 0)
        }, sort_keys=True)
        
        return sm3_hash(block_string.encode())
    
    def add_transaction(self, transaction):
        """添加交易到待处理池"""
        # 验证交易签名
        if not self.verify_transaction(transaction):
            raise ValueError("交易签名无效")
        
        self.pending_transactions.append(transaction)
        
        # 自动打包（实际应用中可设置阈值）
        if len(self.pending_transactions) >= 10:
            self.mine_pending_transactions()
    
    def verify_transaction(self, transaction):
        """验证交易的数字签名"""
        # 提取签名数据
        data_to_verify = {
            "operation": transaction["operation"],
            "actor": transaction["actor"],
            "timestamp": transaction["timestamp"],
            "data_hash": transaction["data_hash"]
        }
        
        data_hash = sm3_hash(json.dumps(data_to_verify, sort_keys=True).encode())
        
        # 使用SM2验证签名
        return sm2_verify(
            data_hash,
            transaction["signature"],
            transaction["actor_public_key"]
        )
    
    def mine_pending_transactions(self):
        """打包待处理交易（简化版挖矿）"""
        if not self.pending_transactions:
            return None
        
        last_block = self.chain[-1]
        
        new_block = {
            "index": len(self.chain),
            "timestamp": datetime.now().isoformat(),
            "transactions": self.pending_transactions.copy(),
            "previous_hash": last_block["hash"],
            "nonce": 0
        }
        
        # 简化版工作量证明（实际可用更复杂的共识机制）
        new_block["nonce"] = self.proof_of_work(new_block)
        new_block["hash"] = self.calculate_hash(new_block)
        
        self.chain.append(new_block)
        self.pending_transactions
