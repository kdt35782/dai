# **系统完整运行逻辑详解**

我将以一个完整的就诊流程为例，详细解释系统中每个角色的交互过程和数据流转。整个系统围绕**数据隐私保护**与**AI智能诊断**的融合展开。

## **一、系统核心角色与初始状态**

### **1.1 角色定义**
- **患者王明**：年龄45岁，有高血压病史，新出现头晕症状
- **医生李华**：心内科主治医师，拥有属性`{科室:心内科, 职位:主治医师, 医院:市人民医院}`
- **AI诊断引擎**：本地部署的轻量级疾病分类模型
- **密钥管理系统(KMS)**：负责管理所有加密密钥
- **区块链存证服务**：模拟的存证节点，存储操作哈希

### **1.2 初始状态准备**
```python
# 系统初始化时生成的关键密钥
系统密钥状态:
1. 患者王明:
   - SM2密钥对: (pub_key_patient, priv_key_patient)  # 身份认证
   - SM4会话密钥: K_session_patient                 # 临时通信加密
   
2. 医生李华:
   - SM2密钥对: (pub_key_doctor, priv_key_doctor)    # 身份认证
   - SM9属性密钥: K_attr_doctor(心内科,主治医师)     # 属性基解密
   
3. 系统公钥:
   - Paillier同态公钥: pub_key_paillier              # AI计算使用
   - SM4主密钥: K_master                             # 数据存储加密
```

## **二、完整运行流程：从症状到诊断**

### **阶段1：患者端症状输入与加密 (前端)**

**时间点：周一上午9:00**

#### **步骤1.1：患者登录与身份验证**
```
患者王明 → 系统:
1. 输入身份证号: 310101197801015678
2. 系统调用SM3计算哈希: H1 = SM3(身份证号)
3. 使用SM2私钥签名: Sig1 = SM2_Sign(H1, priv_key_patient)
4. 发送: {身份证号哈希: H1, 签名: Sig1, 时间戳: T1}

系统 → 患者:
1. 验证SM2签名有效性
2. 生成临时会话密钥: K_session = 随机生成128位
3. 用患者SM2公钥加密: E(K_session) = SM2_Encrypt(K_session, pub_key_patient)
4. 返回: {加密会话密钥: E(K_session), 会话ID: SID123}
```

#### **步骤1.2：症状数据采集与本地加密**
患者填写症状表单：
```json
原始症状数据:
{
  "basic_info": {
    "age": 45,
    "gender": "male",
    "height": 175,
    "weight": 80
  },
  "symptoms": {
    "chief_complaint": "头晕、头痛",
    "duration_days": 3,
    "blood_pressure": "150/95",
    "heart_rate": 88,
    "history": ["hypertension_5_years"]
  },
  "timestamp": "2024-05-20 09:05:00"
}
```

**本地加密过程：**
```python
# 在患者手机端执行的加密
def encrypt_symptoms_locally(symptoms_data):
    # 1. 提取特征向量（用于AI计算）
    features = extract_features(symptoms_data)
    # 示例: [45, 1, 175, 80, 150, 95, 88, 1, 0, 1]
    
    # 2. 用SM4会话密钥加密完整症状描述（文本）
    sm4_cipher = SM4.new(K_session_patient)
    encrypted_text = sm4_cipher.encrypt(json.dumps(symptoms_data))
    
    # 3. 用Paillier公钥加密特征向量（支持加密计算）
    paillier_encrypted_features = []
    for feature in features:
        # Paillier加密每个特征值
        encrypted = paillier_encrypt(feature, pub_key_paillier)
        paillier_encrypted_features.append(encrypted)
    
    return {
        "encrypted_text": encrypted_text,  # SM4加密，供医生查看
        "encrypted_features": paillier_encrypted_features,  # Paillier加密，供AI计算
        "session_id": "SID123",
        "patient_id_hash": H1
    }
```

### **阶段2：安全传输与AI智能诊断 (后端)**

#### **步骤2.1：安全数据传输**
```
患者端 → 安全计算代理:
发送: {
  "type": "diagnosis_request",
  "data": encrypt_symptoms_locally(symptoms_data),
  "signature": SM2_Sign(数据哈希, priv_key_patient)
}

安全计算代理验证:
1. 验证签名有效性
2. 记录操作日志: "患者[哈希]于T1提交诊断请求"
3. 计算操作哈希: H_op1 = SM3(操作记录)
4. 存储到区块链存证: Blockchain.add(H_op1)
```

#### **步骤2.2：隐私保护AI计算（核心）**

**安全计算代理内部处理：**
```python
class SecureAIDiagnosis:
    def process_encrypted_diagnosis(self, encrypted_data):
        # 1. 解密SM4加密的文本（仅用于记录，不用于AI计算）
        sm4_cipher = SM4.new(K_session_patient)
        symptoms_text = sm4_cipher.decrypt(encrypted_data["encrypted_text"])
        
        # 2. AI模型在加密特征上进行计算（不解密Paillier数据）
        encrypted_features = encrypted_data["encrypted_features"]
        
        # 加载预训练的疾病分类模型（已训练好的逻辑回归）
        # 模型参数: weights = [w1, w2, ..., w10], bias = b
        
        # 3. 在加密数据上计算加权和
        encrypted_score = self.encrypted_linear_combination(
            encrypted_features, 
            model_weights, 
            model_bias
        )
        
        # 此时encrypted_score是Paillier加密的风险分数
        
        # 4. 对加密结果进行安全处理
        # 添加随机噪声（差分隐私保护）
        encrypted_noisy_score = self.add_differential_privacy(encrypted_score)
        
        return encrypted_noisy_score
    
    def encrypted_linear_combination(self, enc_features, weights, bias):
        """
        在加密特征上计算: score = Σ(w_i * x_i) + b
        x_i是加密的，w_i和b是明文的
        """
        # Paillier性质: E(w*x) = E(x)^w mod n^2
        n_square = paillier_public_key.n ** 2
        
        # 初始化加密结果为E(0)
        encrypted_sum = paillier_encrypt(0, pub_key_paillier)
        
        # 计算加权和
        for i, enc_x in enumerate(enc_features):
            if weights[i] != 0:
                # E(x)^w = (x^w) mod n^2
                weighted = pow(enc_x, weights[i], n_square)
                encrypted_sum = (encrypted_sum * weighted) % n_square
        
        # 添加偏置项（需要先加密bias）
        encrypted_bias = paillier_encrypt(bias, pub_key_paillier)
        encrypted_result = (encrypted_sum * encrypted_bias) % n_square
        
        return encrypted_result
```

#### **步骤2.3：生成诊断建议**
AI模型基于加密计算得到的风险分数，生成诊断建议：

```python
# 安全计算代理内部
def generate_diagnosis_advice(encrypted_score):
    """
    基于加密风险分数生成建议
    注意：此时分数仍是加密的，我们只能基于加密值的范围判断
    """
    
    # 方案1：客户端解密后判断（保护隐私）
    # 我们将加密结果和判断逻辑一起返回给客户端
    
    # 方案2：安全比较（使用安全多方计算简化版）
    # 这里我们采用方案1，更简单实用
    
    advice_template = {
        "low_risk": "症状较轻，建议休息观察，定期监测血压",
        "medium_risk": "建议线下就诊心内科，进一步检查",
        "high_risk": "建议立即就医，可能存在心血管风险"
    }
    
    # 返回加密结果和判断逻辑
    return {
        "encrypted_risk_score": encrypted_score,
        "advice_templates": advice_template,
        "comparison_thresholds": {
            "low_threshold": paillier_encrypt(30, pub_key_paillier),
            "high_threshold": paillier_encrypt(70, pub_key_paillier)
        }
    }
```

### **阶段3：结果返回与患者端解密**

#### **步骤3.1：加密结果返回**
```
安全计算代理 → 患者端:
{
  "diagnosis_result": {
    "encrypted_risk_score": "Paillier密文...",
    "advice_templates": {...},
    "comparison_thresholds": {...}
  },
  "encrypted_medical_record": {
    "record_id": "REC001",
    "encrypted_data": "SM4密文...",  # 完整加密病历
    "storage_key": "SM4加密的存储密钥"
  },
  "timestamp": "2024-05-20 09:08:00",
  "signature": "SM2签名..."
}
```

#### **步骤3.2：患者端本地解密与展示**
```javascript
// 在患者手机端执行
function decryptAndDisplay(result) {
    // 1. 解密风险分数（使用Paillier私钥）
    // 注意：实际中Paillier私钥由患者持有或托管在安全环境
    const encryptedScore = result.diagnosis_result.encrypted_risk_score;
    const riskScore = paillierDecrypt(encryptedScore, paillierPrivateKey);
    
    // 2. 与阈值比较（在本地明文比较）
    const lowThreshold = 30;
    const highThreshold = 70;
    
    let riskLevel, advice;
    if (riskScore < lowThreshold) {
        riskLevel = "low";
        advice = result.diagnosis_result.advice_templates.low_risk;
    } else if (riskScore < highThreshold) {
        riskLevel = "medium";
        advice = result.diagnosis_result.advice_templates.medium_risk;
    } else {
        riskLevel = "high";
        advice = result.diagnosis_result.advice_templates.high_risk;
    }
    
    // 3. 显示结果
    displayToPatient({
        riskScore: riskScore,
        riskLevel: riskLevel,
        advice: advice,
        timestamp: result.timestamp
    });
    
    // 4. 本地存储加密病历
    localStorage.setItem('medical_record_REC001', 
        JSON.stringify(result.encrypted_medical_record));
}
```

**患者看到的界面：**
```
=== AI智能诊断结果 ===
风险评估分数：65分
风险等级：中等风险
建议：建议线下就诊心内科，进一步检查
时间：2024-05-20 09:08:00

=== 您的加密病历 ===
病历ID：REC001（已加密存储）
```

### **阶段4：线下就诊与医生访问病历**

#### **步骤4.1：患者授权医生访问**
**时间点：周一下午14:00，患者前往医院**

```
患者王明 → 医生李华:
1. 出示就诊二维码（包含病历ID和临时访问令牌）
2. 二维码内容: {
    "record_id": "REC001",
    "patient_id_hash": H1,
    "access_token": "临时令牌",
    "expiry": "2024-05-20 18:00:00"
}

医生李华 → 系统:
1. 扫描二维码
2. 发送访问请求: {
    "doctor_id": "DOC_李华",
    "attributes": ["心内科", "主治医师"],
    "record_id": "REC001",
    "access_token": "临时令牌",
    "signature": SM2_Sign(请求数据, priv_key_doctor)
}
```

#### **步骤4.2：属性基访问控制验证**
```python
# 访问控制模块处理
class AccessControl:
    def verify_doctor_access(self, request):
        # 1. 验证医生签名
        if not verify_signature(request):
            return False
        
        # 2. 验证访问令牌有效性
        if not validate_access_token(request):
            return False
        
        # 3. 检查医生属性是否满足访问策略
        # 病历REC001的访问策略: (科室=心内科 AND 职位>=住院医师)
        policy = get_record_policy(request.record_id)
        
        # 使用SM9属性基加密验证
        if sm9_verify_attributes(request.attributes, policy):
            # 4. 生成访问记录
            log_access(request)
            
            # 5. 返回授权成功和加密密钥
            return {
                "authorized": True,
                "encrypted_record_key": get_encrypted_key(request.record_id),
                "access_id": "ACC001"
            }
        else:
            return {"authorized": False, "reason": "属性不匹配"}
```

#### **步骤4.3：安全病历解密与展示**
```python
# 医生工作站处理
def decrypt_medical_record_for_doctor(authorization_result):
    # 1. 使用医生的SM9属性密钥解密病历存储密钥
    encrypted_key = authorization_result["encrypted_record_key"]
    
    # SM9解密：只有属性匹配的医生才能解密
    record_key = sm9_decrypt(
        encrypted_key, 
        K_attr_doctor,  # 医生的属性密钥
        policy          # 访问策略
    )
    
    # 2. 用解密出的密钥解密病历数据
    encrypted_data = get_encrypted_record("REC001")
    medical_record = sm4_decrypt(encrypted_data, record_key)
    
    # 3. 验证数据完整性
    stored_hash = get_record_hash("REC001")
    computed_hash = sm3_hash(medical_record)
    
    if stored_hash != computed_hash:
        raise IntegrityError("病历数据被篡改")
    
    # 4. 以安全方式显示给医生（防止截屏等）
    secure_display(medical_record)
```

**医生看到的界面：**
```
=== 患者病历（安全视图） ===
患者：[匿名ID: P_7a3b9c]
年龄：45岁 | 性别：男
就诊时间：2024-05-20 09:05:00

主诉：头晕、头痛（持续3天）
血压：150/95 mmHg
心率：88次/分
病史：高血压病史5年

AI初步诊断：
- 风险评分：65/100（中等风险）
- 建议：心内科进一步检查

=== 安全信息 ===
访问ID：ACC001
访问时间：2024-05-20 14:05:00
访问医生：李华（心内科主治医师）
数据完整性：已验证 ✓
```

#### **步骤4.4：医生诊断与处方**
医生根据病历进行诊断，开具电子处方：

```python
# 医生开具处方
prescription = {
    "patient_id_hash": H1,
    "doctor_id": "DOC_李华",
    "diagnosis": "高血压2级，伴有头晕症状",
    "medications": [
        {"name": "氨氯地平", "dose": "5mg", "frequency": "每日一次"},
        {"name": "氢氯噻嗪", "dose": "12.5mg", "frequency": "每日一次"}
    ],
    "advice": "低盐饮食，定期监测血压",
    "follow_up": "2周后复诊",
    "timestamp": "2024-05-20 14:30:00"
}

# 使用医生SM2私钥签名
prescription_signature = sm2_sign(
    sm3_hash(json.dumps(prescription)),
    priv_key_doctor
)

# 处方加密存储
encrypted_prescription = sm4_encrypt(
    json.dumps(prescription),
    K_master  # 系统主密钥
)
```

### **阶段5：审计与存证**

#### **步骤5.1：操作日志记录**
系统自动记录所有关键操作：

```python
# 操作日志示例
operations = [
    {
        "op_id": "OP001",
        "timestamp": "2024-05-20 09:05:00",
        "actor": "患者[哈希]",
        "action": "提交AI诊断请求",
        "data_hash": H_symptoms,
        "signature": Sig_patient
    },
    {
        "op_id": "OP002",
        "timestamp": "2024-05-20 09:08:00",
        "actor": "AI系统",
        "action": "生成诊断结果",
        "data_hash": H_diagnosis,
        "signature": Sig_system
    },
    {
        "op_id": "OP003",
        "timestamp": "2024-05-20 14:05:00",
        "actor": "医生[李华]",
        "action": "访问病历REC001",
        "data_hash": H_access,
        "signature": Sig_doctor
    }
]

# 批量生成存证
for op in operations:
    # 计算操作记录的SM3哈希
    op_hash = sm3_hash(json.dumps(op))
    
    # 存储到模拟区块链
    block_data = {
        "previous_hash": last_block_hash,
        "timestamp": op["timestamp"],
        "operation": op,
        "hash": op_hash
    }
    
    # 添加到链上
    blockchain.add_block(block_data)
    last_block_hash = op_hash
```

#### **步骤5.2：异常检测与告警**
```python
# 实时监控异常访问
def monitor_access_patterns():
    # 1. 检测频繁访问
    recent_accesses = get_recent_accesses("REC001", hours=24)
    if len(recent_accesses) > 5:  # 24小时内访问超过5次
        trigger_alert("异常频繁访问", recent_accesses)
    
    # 2. 检测非授权属性访问尝试
    failed_attempts = get_failed_access_attempts("REC001")
    if len(failed_attempts) > 3:
        trigger_alert("多次非法访问尝试", failed_attempts)
    
    # 3. 检测数据完整性
    for record in all_medical_records():
        if not verify_integrity(record):
            trigger_alert("数据完整性受损", record.id)
```

## **三、数据全生命周期流转**

### **3.1 数据状态变迁**
```
1. 明文阶段 (仅存在于用户设备内存中)
   - 患者输入症状 (9:05)
   - 医生查看诊断结果 (14:05)

2. 传输加密阶段 (SM4 + TLS)
   - 患者 → 服务器 (SM4加密)
   - 服务器 → AI引擎 (Paillier加密)
   - 服务器 → 患者 (SM4加密)

3. 存储加密阶段 (SM4 + 属性基加密)
   - 病历数据库: SM4加密存储
   - 密钥存储: SM9属性基加密
   - 区块链: SM3哈希值

4. 计算加密阶段 (Paillier同态加密)
   - AI风险评分计算全程在加密数据上进行
```

### **3.2 密钥生命周期管理**
```
1. 生成阶段:
   - 患者注册: 生成SM2密钥对
   - 医生入职: 生成SM2密钥对 + SM9属性密钥
   - 会话开始: 生成SM4会话密钥

2. 使用阶段:
   - 身份认证: SM2签名验证
   - 数据传输: SM4对称加密
   - 数据存储: SM4 + SM9组合加密
   - 安全计算: Paillier同态加密

3. 轮换阶段:
   - 会话密钥: 每次会话更换
   - 存储密钥: 每30天轮换
   - 主密钥: 每90天轮换

4. 销毁阶段:
   - 患者注销: 销毁所有相关密钥
   - 医生离职: 撤销属性密钥
   - 数据过期: 安全擦除加密数据
```

## **四、安全边界与信任假设**

### **4.1 系统信任假设**
```
1. 可信执行环境:
   - 安全计算代理是可信的
   - 密钥管理系统是可信的
   - 区块链存证服务是可信的

2. 不可信环境:
   - 网络传输通道 (通过加密保护)
   - 数据库管理员 (只能看到密文)
   - 云服务提供商 (无法访问明文)

3. 部分可信环境:
   - AI服务引擎 (只能访问加密特征)
   - 前端应用程序 (可能被恶意篡改)
```

### **4.2 攻击面与防护措施**
```
1. 网络窃听攻击:
   - 防护: SM4传输加密 + TLS 1.3

2. 中间人攻击:
   - 防护: SM2双向身份认证

3. 数据库泄露:
   - 防护: 全字段SM4加密存储

4. 内部人员滥用:
   - 防护: 属性基访问控制 + 操作审计

5. AI模型逆向攻击:
   - 防护: 加密数据计算 + 差分隐私

6. 重放攻击:
   - 防护: 时间戳 + 唯一会话ID
```

## **五、实际运行中的优化考虑**

### **5.1 性能优化**
```python
# 实际部署时的优化措施
class OptimizedSystem:
    
    def batch_paillier_encryption(self, features):
        """批处理Paillier加密，减少模幂运算"""
        # 预计算加速
        precomputed = precompute_paillier_powers()
        
        # 并行加密多个特征
        with ThreadPoolExecutor() as executor:
            encrypted = list(executor.map(
                lambda x: fast_paillier_encrypt(x, precomputed),
                features
            ))
        
        return encrypted
    
    def cache_encrypted_results(self, patient_id, symptoms_hash):
        """缓存相似症状的加密结果"""
        cache_key = f"{patient_id}_{symptoms_hash}"
        if cache_key in encrypted_cache:
            return encrypted_cache[cache_key]
        
        # 否则正常计算并缓存
        result = compute_encrypted_diagnosis(...)
        encrypted_cache[cache_key] = result
        return result
```

### **5.2 容错处理**
```python
# 系统容错机制
def resilient_diagnosis_flow(symptoms):
    try:
        # 主要路径: 隐私保护AI诊断
        result = privacy_preserving_diagnosis(symptoms)
        return result
        
    except EncryptionError as e:
        # 备用路径1: 降级到本地计算
        logger.warning("加密计算失败，降级到本地安全计算")
        return local_secure_computation(symptoms)
        
    except AIServiceError as e:
        # 备用路径2: 基于规则的诊断
        logger.warning("AI服务不可用，使用规则引擎")
        return rule_based_diagnosis(symptoms)
        
    except Exception as e:
        # 最终备用: 返回安全错误信息
        logger.error(f"诊断系统完全故障: {e}")
        return {
            "status": "error",
            "message": "系统暂时不可用，请稍后重试",
            "emergency_advice": "如症状严重，请立即就医"
        }
```

这个完整的运行逻辑展示了从患者输入症状到医生访问病历的**端到端隐私保护流程**。关键特点是：

1. **全程无明文暴露**：患者敏感数据始终处于加密状态
2. **AI计算不接触明文**：通过同态加密实现隐私保护计算
3. **细粒度访问控制**：基于属性的加密确保只有授权医生可访问
4. **完整审计追溯**：所有操作上链存证，不可篡改
5. **优雅降级机制**：在各种异常情况下仍能提供服务

这样的设计既满足了医疗数据的安全合规要求，又提供了智能化的诊断服务，实现了安全与智能的平衡。